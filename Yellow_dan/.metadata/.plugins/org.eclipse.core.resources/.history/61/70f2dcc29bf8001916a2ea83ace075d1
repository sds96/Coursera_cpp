#ifndef DATABASE_H_
#define DATABASE_H_

#include <iostream>
#include <set>
#include <map>
#include <vector>
#include <algorithm>
#include "date.h"

class Database {
public:
  void Add(const Date& date, const std::string& event);

  bool DeleteEvent(const Date& date, const std::string& event);

  int DeleteDate(const Date& date);

  std::set<std::string> Find(const Date& date) const;

  void Print(std::ostream& os) const;

  std::string Last(const Date& date) const;

  template<typename PredFunc>
    std::vector<std::pair<Date, std::string>> FindIf(PredFunc predicate) const
       {
           std::vector<std::pair<Date, std::string>> Result;
           std::for_each(storage2.begin(),
                         storage2.end(),
                         [&predicate, &Result]
                         (const std::pair<const Date,
                          std::pair<std::vector<std::set<std::string>::iterator>, std::set<std::string>>>& EventsForDate) mutable
           {
                 std::for_each(EventsForDate.second.first.begin(),
                               EventsForDate.second.first.end(),
                               [&predicate, &EventsForDate, &Result] (const std::set<std::string>::iterator& event)
                 {
                     if (predicate(EventsForDate.first, *event)) Result.emplace_back(EventsForDate.first, *event);
                 });
           });
           return Result;
       }

  template<typename PredFunc> int RemoveIf(PredFunc predicate)
  {
      int DeletedCount = 0;
      std::for_each(storage2.begin(),
                    storage2.end(),
                    [&predicate, &DeletedCount]
                    (std::pair<const Date,
                               std::vector<std::string>>
                                          & EventsForDate) mutable
      {
            DeletedCount += EventsForDate.second.size();
            auto it = std::stable_partition(EventsForDate.second.begin(),
                                            EventsForDate.second.end(),
                                            [&EventsForDate, &predicate] (const auto& element)
            {
                return !predicate(EventsForDate.first, element);
            });
            EventsForDate.second.erase(it, EventsForDate.second.end());
            DeletedCount -= EventsForDate.second.size();
      });
      for (auto it = storage2.begin(); it != storage2.end();)
      {
          if (it->second.empty()) {
              storage2.erase(it++);
          } else {
              ++it;
          }
      }
      storage.clear();
      for (const auto& i : storage2){
    	  for (const auto& k: i.second){
        	  storage[i.first].insert(k);
    	  }
      }
      return DeletedCount;
  }

private:
  std::map<Date, std::set<std::string>> storage;  // уникальность
  std::map<Date, std::vector<std::string>> storage2;  // порядок добавления дат
};

#endif /* DATABASE_H_ */
